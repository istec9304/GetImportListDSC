# =============================================
# 📌 임포트체커 (v250723)
# 작성자: 서기대
# 목적: 수용가 단말기 등록용 엑셀 파일을 SQL VALUES 구문으로 자동 변환
# 주요 기능:
#   - 엑셀 파일 선택 창 제공
#   - 정해진 20개 컬럼 기준으로 데이터 파싱
#   - 성공/실패 항목 수 집계
#   - 수용가번호 목록 및 SQL VALUES 구문 출력
#   - 긴 텍스트를 가로/세로 스크롤 가능하게 출력
#   - 유효성 검사 CASE 넘버링 지원
#   - 프로그램 버전: v250723
# =============================================

import gspread
import pandas as pd
import tkinter as tk
from tkinter import filedialog, messagebox
from datetime import datetime
from tkinter import ttk
import psycopg2
from psycopg2 import Error
import re
import os
import sys

# 📌 계정명별 DB 설정 (네트워크 정보가 있는 계정만 설정)
ACCOUNT_DB_CONFIGS = {
    '경북포항': {
        'host': '10.241.240.219',
        'port': 5433,
        'database': 'mars_icbm',
        'user': 'mars_icbm',
        'password': 'mars@icbm'
    },
    '충남태안': {
        'host': '211.53.249.251',
        'port': 5438,
        'database': 'mars_icbm',
        'user': 'mars_icbm',
        'password': 'mars@icbm'
    }
}

# 📌 현재 사용 중인 DB 설정 가져오기
def get_db_config(account_name=None):
    """계정명에 따른 DB 설정 반환 (설정이 없으면 None)"""
    if account_name and account_name in ACCOUNT_DB_CONFIGS:
        return ACCOUNT_DB_CONFIGS[account_name].copy()
    else:
        return None  # 네트워크 정보가 없는 계정

# 📌 엑셀 컬럼명 정의 (20개 항목)
COLUMNS = [
    '수용가명', '수용가번호', '구주소', '신주소', '경도', '위도', '업종', '소속',
    '블록', '수용가 전화번호', '수용가 대상 년도', '검침원', '검침일', '계량기번호',
    '구경', '통신', '단말 부번호', '단말 주번호', '단말 회사', '단말 설치일'
]

# 📌 DB 연결 테스트 및 간단한 쿼리 실행
def test_db_connection():
    try:
        # 비밀번호 가져오기
        db_password = db_password_entry.get()
        if not db_password:
            messagebox.showwarning("비밀번호 입력", "DB 비밀번호를 입력하세요.")
            return
        
        # 선택된 계정명에 따른 DB 설정 가져오기
        selected_name = site_entry.get().strip()
        db_config = get_db_config(selected_name)
        
        if db_config is None:
            messagebox.showerror(
                "네트워크 정보 없음", 
                f"'{selected_name}' 계정은 DB 네트워크 정보가 설정되어 있지 않습니다.\n\n설정된 계정:\n" + 
                "\n".join([f"★ {name}" for name in ACCOUNT_DB_CONFIGS.keys()])
            )
            return
        
        # 비밀번호 설정 (입력된 비밀번호 우선, 없으면 계정 설정 비밀번호 사용)
        if db_password:
            db_config['password'] = db_password
        elif not db_config.get('password'):
            messagebox.showwarning("비밀번호 입력", "DB 비밀번호를 입력하세요.")
            return
        
        # DB 연결
        connection = psycopg2.connect(**db_config)
        cursor = connection.cursor()
        
        # 간단한 테스트 쿼리
        cursor.execute("SELECT version();")
        db_version = cursor.fetchone()
        
        # 테이블 목록 조회
        cursor.execute("""
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'public' 
            ORDER BY table_name 
            LIMIT 10;
        """)
        tables = cursor.fetchall()
        
        # 결과 출력 (로그 형식)
        from datetime import datetime
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        result_text.config(state=tk.NORMAL)
        result_text.insert(tk.END, f"\n{'='*120}\n")
        result_text.insert(tk.END, f"✅ DB 연결 테스트 - {current_time}\n")
        result_text.insert(tk.END, f"Host: {db_config['host']}:{db_config['port']}\n")
        result_text.insert(tk.END, f"{'='*120}\n\n")
        result_text.insert(tk.END, f"📌 PostgreSQL 버전:\n{db_version[0]}\n\n")
        result_text.insert(tk.END, f"📌 테이블 목록 (최대 10개):\n")
        for idx, table in enumerate(tables, 1):
            result_text.insert(tk.END, f"{idx}. {table[0]}\n")
        result_text.insert(tk.END, "\n")
        result_text.see(tk.END)
        result_text.config(state=tk.DISABLED)
        
        cursor.close()
        connection.close()
        
        messagebox.showinfo("DB 연결 성공", "데이터베이스 연결에 성공했습니다!")
        
    except Error as e:
        messagebox.showerror("DB 연결 오류", f"데이터베이스 연결 실패:\n{e}")
    except Exception as e:
        messagebox.showerror("오류 발생", f"예상치 못한 오류:\n{e}")

# 📌 매핑 조회 함수 (수용가번호 또는 단말주번호 자동 감지, 다중 입력 지원)
def search_mapping():
    try:
        # 비밀번호 가져오기
        db_password = db_password_entry.get()
        if not db_password:
            messagebox.showwarning("비밀번호 입력", "DB 비밀번호를 입력하세요.")
            return
        
        # 검색어 가져오기 (Text 위젯에서 가져오기)
        search_text = mapping_search_text.get("1.0", tk.END).strip()
        if not search_text:
            messagebox.showwarning("검색어 입력", "수용가번호 또는 단말주번호를 입력하세요.")
            return
        
        # 입력값 파싱 (줄바꿈, 쉼표, 공백으로 구분)
        search_values = re.split(r'[\n,\s]+', search_text)
        search_values = [v.strip() for v in search_values if v.strip()]
        
        if not search_values:
            messagebox.showwarning("검색어 입력", "유효한 수용가번호 또는 단말주번호를 입력하세요.")
            return
        
        # 선택된 계정명에 따른 DB 설정 가져오기
        selected_name = site_entry.get().strip()
        db_config = get_db_config(selected_name)
        
        if db_config is None:
            messagebox.showerror(
                "네트워크 정보 없음", 
                f"'{selected_name}' 계정은 DB 네트워크 정보가 설정되어 있지 않습니다.\n\n설정된 계정:\n" + 
                "\n".join([f"★ {name}" for name in ACCOUNT_DB_CONFIGS.keys()])
            )
            return
        
        # 비밀번호 설정 (입력된 비밀번호 우선, 없으면 계정 설정 비밀번호 사용)
        if db_password:
            db_config['password'] = db_password
        elif not db_config.get('password'):
            messagebox.showwarning("비밀번호 입력", "DB 비밀번호를 입력하세요.")
            return
        
        # DB 연결
        connection = psycopg2.connect(**db_config)
        cursor = connection.cursor()
        
        # 입력값을 단말주번호와 수용가번호로 분류
        device_nos = []
        admin_nos = []
        
        for value in search_values:
            if value.startswith('012') and len(value) == 11:
                device_nos.append(value)
            else:
                admin_nos.append(value)
        
        # 결과를 딕셔너리로 저장 (검색 키별로)
        results_dict = {}
        
        # 단말주번호로 조회
        if device_nos:
            placeholders = ','.join(['%s'] * len(device_nos))
            query = f"""
                SELECT c.admin_no, d.dev_no, d.sub_dev_no, d.point_sq, p.cust_sq
                FROM public.tb_m1_cmap_device d
                LEFT JOIN public.tb_m1_info_point p ON d.point_sq = p.point_sq
                LEFT JOIN public.tb_m1_info_customer c ON p.cust_sq = c.cust_sq
                WHERE d.dev_no IN ({placeholders});
            """
            cursor.execute(query, device_nos)
            for row in cursor.fetchall():
                results_dict[row[1]] = row  # dev_no를 키로 사용
        
        # 수용가번호로 조회
        if admin_nos:
            placeholders = ','.join(['%s'] * len(admin_nos))
            query = f"""
                SELECT c.admin_no, d.dev_no, d.sub_dev_no, d.point_sq, p.cust_sq
                FROM public.tb_m1_cmap_device d
                JOIN public.tb_m1_info_point p ON d.point_sq = p.point_sq
                JOIN public.tb_m1_info_customer c ON p.cust_sq = c.cust_sq
                WHERE c.admin_no IN ({placeholders});
            """
            cursor.execute(query, admin_nos)
            for row in cursor.fetchall():
                results_dict[row[0]] = row  # admin_no를 키로 사용
        
        # 입력 순서대로 결과 정렬
        all_results = []
        for search_val in search_values:
            if search_val in results_dict:
                all_results.append(results_dict[search_val])
        
        # 결과 출력 (로그 형식 - 누적)
        from datetime import datetime
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        result_text.config(state=tk.NORMAL)
        # delete 제거 - 로그 누적
        result_text.insert(tk.END, f"\n{'='*120}\n")
        result_text.insert(tk.END, f"🔍 매핑 조회 결과 - {current_time}\n")
        result_text.insert(tk.END, f"검색 항목: {len(search_values)}개 (단말주번호: {len(device_nos)}개, 수용가번호: {len(admin_nos)}개)\n")
        result_text.insert(tk.END, f"{'='*120}\n\n")
        
        if all_results:
            result_text.insert(tk.END, f"✅ {len(all_results)}개의 매핑 발견\n\n")
            result_text.insert(tk.END, f"{'수용가번호':<20} {'단말부번호':<30} {'단말주번호':<15} {'point_sq':<10} {'cust_sq':<10}\n")
            result_text.insert(tk.END, "-"*120 + "\n")
            for admin_no, dev_no, sub_dev_no, point_sq, cust_sq in all_results:
                # NULL 값 처리
                admin_no_str = admin_no if admin_no else 'NULL'
                sub_dev_no_str = sub_dev_no if sub_dev_no else 'NULL'
                point_sq_str = str(point_sq) if point_sq else 'NULL'
                cust_sq_str = str(cust_sq) if cust_sq else 'NULL'
                result_text.insert(tk.END, f"{admin_no_str:<20} {sub_dev_no_str:<30} {dev_no:<15} {point_sq_str:<10} {cust_sq_str:<10}\n")
        else:
            result_text.insert(tk.END, "❌ 매핑된 데이터가 없습니다.\n")
        
        result_text.insert(tk.END, "\n")
        # 자동 스크롤 (최신 로그로)
        result_text.see(tk.END)
        result_text.config(state=tk.DISABLED)
        
        cursor.close()
        connection.close()
        
    except Error as e:
        messagebox.showerror("DB 쿼리 오류", f"데이터베이스 쿼리 실패:\n{e}")
    except Exception as e:
        messagebox.showerror("오류 발생", f"예상치 못한 오류:\n{e}")

# 📌 매핑해제 함수 (단말주번호와 수용가번호 연결 해제)
def unlink_mapping():
    try:
        # 비밀번호 가져오기
        db_password = db_password_entry.get()
        if not db_password:
            messagebox.showwarning("비밀번호 입력", "DB 비밀번호를 입력하세요.")
            return
        
        # 검색어 가져오기
        search_text = mapping_search_text.get("1.0", tk.END).strip()
        if not search_text:
            messagebox.showwarning("검색어 입력", "수용가번호 또는 단말주번호를 입력하세요.")
            return
        
        # 입력값 파싱
        search_values = re.split(r'[\n,\s]+', search_text)
        search_values = [v.strip() for v in search_values if v.strip()]
        
        if not search_values:
            messagebox.showwarning("검색어 입력", "유효한 수용가번호 또는 단말주번호를 입력하세요.")
            return
        
        # 확인 메시지
        if not messagebox.askyesno("매핑해제 확인", f"{len(search_values)}개의 매핑을 해제하시겠습니까?\n\npoint_sq를 NULL로 설정합니다."):
            return
        
        # 선택된 계정명에 따른 DB 설정 가져오기
        selected_name = site_entry.get().strip()
        db_config = get_db_config(selected_name)
        
        if db_config is None:
            messagebox.showerror(
                "네트워크 정보 없음", 
                f"'{selected_name}' 계정은 DB 네트워크 정보가 설정되어 있지 않습니다.\n\n설정된 계정:\n" + 
                "\n".join([f"★ {name}" for name in ACCOUNT_DB_CONFIGS.keys()])
            )
            return
        
        # 비밀번호 설정 (입력된 비밀번호 우선, 없으면 계정 설정 비밀번호 사용)
        if db_password:
            db_config['password'] = db_password
        elif not db_config.get('password'):
            messagebox.showwarning("비밀번호 입력", "DB 비밀번호를 입력하세요.")
            return
        
        # DB 연결
        connection = psycopg2.connect(**db_config)
        cursor = connection.cursor()
        
        # 입력값을 단말주번호와 수용가번호로 분류
        device_nos = []
        admin_nos = []
        
        for value in search_values:
            if value.startswith('012') and len(value) == 11:
                device_nos.append(value)
            else:
                admin_nos.append(value)
        
        unlinked_count = 0
        
        # 트리거 비활성화
        cursor.execute("ALTER TABLE public.tb_m1_cmap_device DISABLE TRIGGER ALL;")
        
        # 단말주번호로 매핑해제 (point_sq를 NULL로 설정)
        if device_nos:
            placeholders = ','.join(['%s'] * len(device_nos))
            
            # 1. 해제 전 상태를 백업 이력에 저장
            backup_query = f"""
                INSERT INTO public.tb_m1_cmap_device_back_his 
                (dev_no, sub_dev_no, point_sq, company_sq, ami_type, ins_dt, upd_dt, his_dt, his_cd)
                SELECT dev_no, sub_dev_no, point_sq, company_sq, ami_type, ins_dt, 
                       CURRENT_TIMESTAMP, TO_CHAR(CURRENT_DATE, 'YYYYMMDD'), 'UNLINK'
                FROM public.tb_m1_cmap_device
                WHERE dev_no IN ({placeholders})
                AND point_sq IS NOT NULL;
            """
            cursor.execute(backup_query, device_nos)
            
            # 2. 매핑 해제
            query = f"""
                UPDATE public.tb_m1_cmap_device
                SET point_sq = NULL
                WHERE dev_no IN ({placeholders});
            """
            cursor.execute(query, device_nos)
            unlinked_count += cursor.rowcount
        
        # 수용가번호로 매핑해제 (해당 수용가의 모든 단말 매핑 해제)
        if admin_nos:
            placeholders = ','.join(['%s'] * len(admin_nos))
            
            # 1. 해제 전 상태를 백업 이력에 저장
            backup_query = f"""
                WITH point_to_delete AS (
                    SELECT p.point_sq
                    FROM public.tb_m1_info_point p
                    JOIN public.tb_m1_info_customer c ON p.cust_sq = c.cust_sq
                    WHERE c.admin_no IN ({placeholders})
                )
                INSERT INTO public.tb_m1_cmap_device_back_his 
                (dev_no, sub_dev_no, point_sq, company_sq, ami_type, ins_dt, upd_dt, his_dt, his_cd)
                SELECT dev_no, sub_dev_no, point_sq, company_sq, ami_type, ins_dt, 
                       CURRENT_TIMESTAMP, TO_CHAR(CURRENT_DATE, 'YYYYMMDD'), 'UNLINK'
                FROM public.tb_m1_cmap_device
                WHERE point_sq IN (SELECT point_sq FROM point_to_delete)
                AND point_sq IS NOT NULL;
            """
            cursor.execute(backup_query, admin_nos)
            
            # 2. 매핑 해제
            query = f"""
                WITH point_to_delete AS (
                    SELECT p.point_sq
                    FROM public.tb_m1_info_point p
                    JOIN public.tb_m1_info_customer c ON p.cust_sq = c.cust_sq
                    WHERE c.admin_no IN ({placeholders})
                )
                UPDATE public.tb_m1_cmap_device
                SET point_sq = NULL
                WHERE point_sq IN (SELECT point_sq FROM point_to_delete);
            """
            cursor.execute(query, admin_nos)
            unlinked_count += cursor.rowcount
        
        # 트리거 활성화
        cursor.execute("ALTER TABLE public.tb_m1_cmap_device ENABLE TRIGGER ALL;")
        
        # 변경사항 커밋
        connection.commit()
        
        # 결과 출력 (로그 형식)
        from datetime import datetime
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        result_text.config(state=tk.NORMAL)
        result_text.insert(tk.END, f"\n{'='*120}\n")
        result_text.insert(tk.END, f"🗑️ 매핑해제 완료 - {current_time}\n")
        result_text.insert(tk.END, f"{'='*120}\n\n")
        result_text.insert(tk.END, f"✅ {unlinked_count}개의 매핑이 해제되었습니다.\n")
        result_text.insert(tk.END, f"📌 처리된 항목: 단말주번호 {len(device_nos)}개, 수용가번호 {len(admin_nos)}개\n")
        result_text.insert(tk.END, f"💡 point_sq → NULL, 백업 이력 저장 (his_cd='UNLINK')\n\n")
        result_text.see(tk.END)
        result_text.config(state=tk.DISABLED)
        
        cursor.close()
        connection.close()
        
        messagebox.showinfo("매핑해제 완료", f"{unlinked_count}개의 매핑이 해제되었습니다.")
        
    except Error as e:
        # 에러 발생 시 트리거 재활성화 시도
        try:
            cursor.execute("ALTER TABLE public.tb_m1_cmap_device ENABLE TRIGGER ALL;")
            connection.commit()
        except:
            pass
        messagebox.showerror("DB 쿼리 오류", f"데이터베이스 쿼리 실패:\n{e}")
    except Exception as e:
        messagebox.showerror("오류 발생", f"예상치 못한 오류:\n{e}")

# 📌 매핑 생성 함수 (수용가번호-단말주번호 1:1 매핑)
def create_mapping():
    try:
        # 비밀번호 가져오기
        db_password = db_password_entry.get()
        if not db_password:
            messagebox.showwarning("비밀번호 입력", "DB 비밀번호를 입력하세요.")
            return
        
        # 검색어 가져오기
        search_text = mapping_search_text.get("1.0", tk.END).strip()
        if not search_text:
            messagebox.showwarning("입력 오류", "수용가번호-단말주번호를 입력하세요.\n예: 2-001302290000,01236564855")
            return
        
        # 입력값 파싱 (수용가번호-단말주번호 또는 수용가번호,단말주번호 형식)
        lines = search_text.split('\n')
        mapping_pairs = []
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # '-' 또는 ',' 또는 공백으로 구분
            if ',' in line:
                parts = line.split(',')
            elif '-' in line and line.count('-') >= 2:  # 수용가번호에 이미 '-'가 있으므로 2개 이상일 때
                # 마지막 '-'를 기준으로 분리
                idx = line.rfind('-')
                if idx > 0 and line[idx+1:].startswith('012'):  # 단말주번호는 012로 시작
                    parts = [line[:idx], line[idx+1:]]
                else:
                    parts = line.split()
            else:
                parts = line.split()
            
            if len(parts) >= 2:
                admin_no = parts[0].strip()
                dev_no = parts[1].strip()
                
                # 단말주번호 검증 (012로 시작하는 11자리)
                if dev_no.startswith('012') and len(dev_no) == 11:
                    mapping_pairs.append((admin_no, dev_no))
                else:
                    messagebox.showwarning("입력 오류", f"잘못된 단말주번호: {dev_no}\n단말주번호는 012로 시작하는 11자리여야 합니다.")
                    return
        
        if not mapping_pairs:
            messagebox.showwarning("입력 오류", "유효한 매핑 쌍을 입력하세요.\n형식: 수용가번호,단말주번호 또는 수용가번호 단말주번호")
            return
        
        # 확인 메시지
        if not messagebox.askyesno("매핑 생성 확인", f"{len(mapping_pairs)}개의 매핑을 생성하시겠습니까?"):
            return
        
        # 선택된 계정명에 따른 DB 설정 가져오기
        selected_name = site_entry.get().strip()
        db_config = get_db_config(selected_name)
        
        if db_config is None:
            messagebox.showerror(
                "네트워크 정보 없음", 
                f"'{selected_name}' 계정은 DB 네트워크 정보가 설정되어 있지 않습니다.\n\n설정된 계정:\n" + 
                "\n".join([f"★ {name}" for name in ACCOUNT_DB_CONFIGS.keys()])
            )
            return
        
        # 비밀번호 설정 (입력된 비밀번호 우선, 없으면 계정 설정 비밀번호 사용)
        if db_password:
            db_config['password'] = db_password
        elif not db_config.get('password'):
            messagebox.showwarning("비밀번호 입력", "DB 비밀번호를 입력하세요.")
            return
        
        # DB 연결
        connection = psycopg2.connect(**db_config)
        cursor = connection.cursor()
        
        # 트리거 비활성화
        cursor.execute("ALTER TABLE public.tb_m1_cmap_device DISABLE TRIGGER ALL;")
        
        # 1. 모든 단말주번호가 매핑해제 상태인지 확인
        dev_nos = [dev_no for _, dev_no in mapping_pairs]
        placeholders = ','.join(['%s'] * len(dev_nos))
        check_query = f"""
            SELECT dev_no, point_sq 
            FROM public.tb_m1_cmap_device 
            WHERE dev_no IN ({placeholders})
            AND point_sq IS NOT NULL;
        """
        cursor.execute(check_query, dev_nos)
        already_mapped = cursor.fetchall()
        
        if already_mapped:
            # 트리거 활성화
            cursor.execute("ALTER TABLE public.tb_m1_cmap_device ENABLE TRIGGER ALL;")
            cursor.close()
            connection.close()
            
            # 이미 매핑된 단말 목록 표시
            mapped_list = "\n".join([f"  - {dev_no} (point_sq: {point_sq})" for dev_no, point_sq in already_mapped])
            messagebox.showerror(
                "매핑 오류", 
                f"다음 단말주번호는 이미 매핑되어 있습니다:\n\n{mapped_list}\n\n먼저 매핑해제를 진행하세요."
            )
            return
        
        # 2. 매핑 생성
        created_count = 0
        for admin_no, dev_no in mapping_pairs:
            query = """
                WITH point_to_update AS (
                    SELECT c.admin_no, p.point_sq
                    FROM public.tb_m1_info_point p
                    JOIN public.tb_m1_info_customer c ON p.cust_sq = c.cust_sq
                    WHERE c.admin_no = %s
                )
                UPDATE public.tb_m1_cmap_device AS dev
                SET point_sq = ptu.point_sq
                FROM point_to_update AS ptu
                WHERE dev.dev_no = %s AND ptu.admin_no = %s;
            """
            cursor.execute(query, (admin_no, dev_no, admin_no))
            created_count += cursor.rowcount
        
        # 3. 생성 후 상태를 백업 이력에 저장
        if dev_nos:
            placeholders = ','.join(['%s'] * len(dev_nos))
            backup_query = f"""
                INSERT INTO public.tb_m1_cmap_device_back_his 
                (dev_no, sub_dev_no, point_sq, company_sq, ami_type, ins_dt, upd_dt, his_dt, his_cd)
                SELECT dev_no, sub_dev_no, point_sq, company_sq, ami_type, ins_dt, 
                       CURRENT_TIMESTAMP, TO_CHAR(CURRENT_DATE, 'YYYYMMDD'), 'CREATE'
                FROM public.tb_m1_cmap_device
                WHERE dev_no IN ({placeholders})
                AND point_sq IS NOT NULL;
            """
            cursor.execute(backup_query, dev_nos)
        
        # 트리거 활성화
        cursor.execute("ALTER TABLE public.tb_m1_cmap_device ENABLE TRIGGER ALL;")
        
        # 변경사항 커밋
        connection.commit()
        
        # 결과 출력 (로그 형식)
        from datetime import datetime
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        result_text.config(state=tk.NORMAL)
        result_text.insert(tk.END, f"\n{'='*120}\n")
        result_text.insert(tk.END, f"✨ 매핑 생성 완료 - {current_time}\n")
        result_text.insert(tk.END, f"{'='*120}\n\n")
        result_text.insert(tk.END, f"✅ {created_count}개의 매핑이 생성되었습니다.\n\n")
        result_text.insert(tk.END, f"📌 생성된 매핑:\n")
        for admin_no, dev_no in mapping_pairs:
            result_text.insert(tk.END, f"   {admin_no} ← {dev_no}\n")
        result_text.insert(tk.END, f"\n💾 백업 이력 저장 (his_cd='CREATE')\n\n")
        result_text.see(tk.END)
        result_text.config(state=tk.DISABLED)
        
        cursor.close()
        connection.close()
        
        messagebox.showinfo("매핑 생성 완료", f"{created_count}개의 매핑이 생성되었습니다.")
        
    except Error as e:
        # 에러 발생 시 트리거 재활성화 시도
        try:
            cursor.execute("ALTER TABLE public.tb_m1_cmap_device ENABLE TRIGGER ALL;")
            connection.commit()
        except:
            pass
        messagebox.showerror("DB 쿼리 오류", f"데이터베이스 쿼리 실패:\n{e}")
    except Exception as e:
        messagebox.showerror("오류 발생", f"예상치 못한 오류:\n{e}")

# 📌 매핑원복 함수 (백업에서 원상태로 복원)
def restore_mapping():
    try:
        # 비밀번호 가져오기
        db_password = db_password_entry.get()
        if not db_password:
            messagebox.showwarning("비밀번호 입력", "DB 비밀번호를 입력하세요.")
            return
        
        # 검색어 가져오기
        search_text = mapping_search_text.get("1.0", tk.END).strip()
        if not search_text:
            messagebox.showwarning("검색어 입력", "수용가번호 또는 단말주번호를 입력하세요.")
            return
        
        # 입력값 파싱
        search_values = re.split(r'[\n,\s]+', search_text)
        search_values = [v.strip() for v in search_values if v.strip()]
        
        if not search_values:
            messagebox.showwarning("검색어 입력", "유효한 수용가번호 또는 단말주번호를 입력하세요.")
            return
        
        # 확인 메시지
        if not messagebox.askyesno("매핑원복 확인", f"{len(search_values)}개의 매핑을 백업에서 원복하시겠습니까?\n\n백업 테이블(tb_m1_cmap_device_back_his)에서 복원합니다."):
            return
        
        # 선택된 계정명에 따른 DB 설정 가져오기
        selected_name = site_entry.get().strip()
        db_config = get_db_config(selected_name)
        
        if db_config is None:
            messagebox.showerror(
                "네트워크 정보 없음", 
                f"'{selected_name}' 계정은 DB 네트워크 정보가 설정되어 있지 않습니다.\n\n설정된 계정:\n" + 
                "\n".join([f"★ {name}" for name in ACCOUNT_DB_CONFIGS.keys()])
            )
            return
        
        # 비밀번호 설정 (입력된 비밀번호 우선, 없으면 계정 설정 비밀번호 사용)
        if db_password:
            db_config['password'] = db_password
        elif not db_config.get('password'):
            messagebox.showwarning("비밀번호 입력", "DB 비밀번호를 입력하세요.")
            return
        
        # DB 연결
        connection = psycopg2.connect(**db_config)
        cursor = connection.cursor()
        
        # 입력값을 단말주번호와 수용가번호로 분류
        device_nos = []
        admin_nos = []
        
        for value in search_values:
            if value.startswith('012') and len(value) == 11:
                device_nos.append(value)
            else:
                admin_nos.append(value)
        
        restored_count = 0
        
        # 트리거 비활성화
        cursor.execute("ALTER TABLE public.tb_m1_cmap_device DISABLE TRIGGER ALL;")
        
        # 단말주번호로 백업에서 복원 (가장 최근 이력 사용)
        if device_nos:
            placeholders = ','.join(['%s'] * len(device_nos))
            
            # 1. 복원 실행
            query = f"""
                WITH latest_backup AS (
                    SELECT DISTINCT ON (dev_no) dev_no, point_sq
                    FROM public.tb_m1_cmap_device_back_his
                    WHERE dev_no IN ({placeholders})
                    AND point_sq IS NOT NULL
                    ORDER BY dev_no, his_dt DESC, upd_dt DESC
                )
                UPDATE public.tb_m1_cmap_device AS dev
                SET point_sq = lb.point_sq
                FROM latest_backup AS lb
                WHERE dev.dev_no = lb.dev_no;
            """
            cursor.execute(query, device_nos)
            restored_count += cursor.rowcount
            
            # 2. 복원 후 상태를 백업 이력에 저장
            backup_query = f"""
                INSERT INTO public.tb_m1_cmap_device_back_his 
                (dev_no, sub_dev_no, point_sq, company_sq, ami_type, ins_dt, upd_dt, his_dt, his_cd)
                SELECT dev_no, sub_dev_no, point_sq, company_sq, ami_type, ins_dt, 
                       CURRENT_TIMESTAMP, TO_CHAR(CURRENT_DATE, 'YYYYMMDD'), 'RESTORE'
                FROM public.tb_m1_cmap_device
                WHERE dev_no IN ({placeholders})
                AND point_sq IS NOT NULL;
            """
            cursor.execute(backup_query, device_nos)
        
        # 수용가번호로 백업에서 복원 (가장 최근 이력 사용)
        if admin_nos:
            placeholders = ','.join(['%s'] * len(admin_nos))
            
            # 1. 복원 실행
            query = f"""
                WITH latest_backup AS (
                    SELECT DISTINCT ON (bak.dev_no) bak.dev_no, bak.point_sq
                    FROM public.tb_m1_cmap_device_back_his bak
                    JOIN public.tb_m1_info_point p ON bak.point_sq = p.point_sq
                    JOIN public.tb_m1_info_customer c ON p.cust_sq = c.cust_sq
                    WHERE c.admin_no IN ({placeholders})
                    AND bak.point_sq IS NOT NULL
                    ORDER BY bak.dev_no, bak.his_dt DESC, bak.upd_dt DESC
                )
                UPDATE public.tb_m1_cmap_device AS dev
                SET point_sq = lb.point_sq
                FROM latest_backup AS lb
                WHERE dev.dev_no = lb.dev_no;
            """
            cursor.execute(query, admin_nos)
            restored_count += cursor.rowcount
            
            # 2. 복원 후 상태를 백업 이력에 저장
            backup_query = f"""
                WITH latest_backup AS (
                    SELECT DISTINCT ON (bak.dev_no) bak.dev_no
                    FROM public.tb_m1_cmap_device_back_his bak
                    JOIN public.tb_m1_info_point p ON bak.point_sq = p.point_sq
                    JOIN public.tb_m1_info_customer c ON p.cust_sq = c.cust_sq
                    WHERE c.admin_no IN ({placeholders})
                    AND bak.point_sq IS NOT NULL
                    ORDER BY bak.dev_no, bak.his_dt DESC, bak.upd_dt DESC
                )
                INSERT INTO public.tb_m1_cmap_device_back_his 
                (dev_no, sub_dev_no, point_sq, company_sq, ami_type, ins_dt, upd_dt, his_dt, his_cd)
                SELECT dev.dev_no, dev.sub_dev_no, dev.point_sq, dev.company_sq, dev.ami_type, dev.ins_dt, 
                       CURRENT_TIMESTAMP, TO_CHAR(CURRENT_DATE, 'YYYYMMDD'), 'RESTORE'
                FROM public.tb_m1_cmap_device dev
                WHERE dev.dev_no IN (SELECT dev_no FROM latest_backup)
                AND dev.point_sq IS NOT NULL;
            """
            cursor.execute(backup_query, admin_nos)
        
        # 트리거 활성화
        cursor.execute("ALTER TABLE public.tb_m1_cmap_device ENABLE TRIGGER ALL;")
        
        # 변경사항 커밋
        connection.commit()
        
        # 결과 출력 (로그 형식)
        from datetime import datetime
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        result_text.config(state=tk.NORMAL)
        result_text.insert(tk.END, f"\n{'='*120}\n")
        result_text.insert(tk.END, f"🔄 매핑원복 완료 - {current_time}\n")
        result_text.insert(tk.END, f"{'='*120}\n\n")
        result_text.insert(tk.END, f"✅ {restored_count}개의 매핑이 원복되었습니다.\n")
        result_text.insert(tk.END, f"📌 처리된 항목: 단말주번호 {len(device_nos)}개, 수용가번호 {len(admin_nos)}개\n")
        result_text.insert(tk.END, f"💡 백업 테이블에서 point_sq 복원, 백업 이력 저장 (his_cd='RESTORE')\n\n")
        result_text.see(tk.END)
        result_text.config(state=tk.DISABLED)
        
        cursor.close()
        connection.close()
        
        messagebox.showinfo("매핑원복 완료", f"{restored_count}개의 매핑이 백업에서 원복되었습니다.")
        
    except Error as e:
        # 에러 발생 시 트리거 재활성화 시도
        try:
            cursor.execute("ALTER TABLE public.tb_m1_cmap_device ENABLE TRIGGER ALL;")
            connection.commit()
        except:
            pass
        messagebox.showerror("DB 쿼리 오류", f"데이터베이스 쿼리 실패:\n{e}")
    except Exception as e:
        messagebox.showerror("오류 발생", f"예상치 못한 오류:\n{e}")

# 📌 엑셀 파일을 읽고 SQL VALUES 구문 생성하는 함수
def generate_sql_from_excel():
    # 파일 선택 창 열기
    file_path = filedialog.askopenfilename(title="엑셀 파일 선택", filetypes=[("Excel files", "*.xlsx *.xls")])
    if not file_path:
        messagebox.showwarning("파일 선택", "파일이 선택되지 않았습니다.")
        return

    # ▶ 입력된 계정명의 수용가번호길이 가져오기
    selected_name = site_entry.get().strip()
    if not selected_name:
        messagebox.showwarning("계정명 선택", "먼저 계정명을 입력하세요.")
        return
    
    # filtered_df에서 선택된 계정명 찾기
    matches = filtered_df[filtered_df['계정명'] == selected_name]
    if matches.empty:
        messagebox.showwarning("계정명 오류", f"'{selected_name}'은(는) 유효한 계정명이 아닙니다.")
        return
    
    try:
        selected_num_len = int(matches.iloc[0]['수용가번호길이'])
    except Exception:
        messagebox.showerror("계정명 오류", "선택한 계정의 수용가번호길이 값이 올바르지 않습니다.")
        return

    # ▶ 소속/단말회사 값 가져오기
    company_value = company_entry.get().strip()
    if not company_value:
        messagebox.showwarning("입력 오류", "소속/단말회사 값을 입력하세요.")
        return
    try:
        company_sq = int(company_value)
    except ValueError:
        messagebox.showerror("입력 오류", "소속/단말회사 값은 정수로 입력해야 합니다.")
        return

    try:
        # 엑셀 데이터프레임 불러오기 및 공백 채움
        df = pd.read_excel(file_path, dtype=str).fillna('')
        df = df.iloc[:, 1:1+len(COLUMNS)]  # 첫 열 제외 후 20열만 선택
        df.columns = COLUMNS

        # ▶ 중복 수용가번호 미리 집계
        admin_no_counts = df['수용가번호'].value_counts()
        duplicated_admin_nos = set(admin_no_counts[admin_no_counts > 1].index)

        values_list = []
        success_count = 0
        fail_count = 0
        success_admin_no_list = []  # 성공한 수용가번호 저장

        # 각 행 반복 처리
        validation_cases = [
            ("수용가번호 길이 검사", lambda row: len(row['수용가번호']) == selected_num_len, "수용가번호 길이 불일치"),
            ("수용가번호 중복 검사", lambda row: row['수용가번호'] not in duplicated_admin_nos, "수용가번호 중복"),
            ("수용가 전화번호 길이 검사", lambda row: len(row['수용가 전화번호']) < 14, "수용가 전화번호 13자리 초과"),
            
        ]

        for idx_row, row in df.iterrows():
            try:
                for case_num, (desc, check_func, err_msg) in enumerate(validation_cases, 1):
                    if not check_func(row):
                        raise ValueError(f"[CASE #{case_num}] {err_msg} (값: {row['수용가번호']})")
                # 숫자 변환이 필요한 컬럼에 대해 값이 비어있으면 예외 발생
                def safe_float(val, col):
                    if val == '':
                        raise ValueError(f"{col} 값이 비어있음")
                    return float(val)
                def safe_int(val, col):
                    if val == '':
                        raise ValueError(f"{col} 값이 비어있음")
                    return int(float(val))
                values = (
                    row['수용가명'],
                    row['수용가번호'],
                    row['구주소'],
                    row['신주소'],
                    safe_float(row['경도'], '경도'),
                    safe_float(row['위도'], '위도'),
                    row['업종'],
                    company_sq,
                    row['블록'],
                    row['수용가 전화번호'],
                    row['수용가 대상 년도'],
                    row['검침원'],
                    safe_int(row['검침일'], '검침일'),
                    row['계량기번호'],
                    safe_int(row['구경'], '구경'),
                    row['통신'],
                    row['단말 부번호'],
                    row['단말 주번호'],
                    company_sq,
                    f"{pd.to_datetime(row['단말 설치일']).date()}"
                )
                # SQL VALUES 문자열 포맷팅
                formatted = "('{}', '{}', '{}', '{}', {}, {}, '{}', {}, '{}', '{}', '{}', '{}', {}, '{}', {}, '{}', '{}', '{}', {}, '{}'::timestamp)".format(*values)
                values_list.append(formatted)
                success_admin_no_list.append(row['수용가번호'])
                success_count += 1
            except Exception as e:
                values_list.append(f"-- [ERROR #{idx_row+1}] {e}")
                fail_count += 1

        # 결과 출력 (로그 형식)
        from datetime import datetime
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        result_text.config(state=tk.NORMAL)
        result_text.insert(tk.END, f"\n{'='*120}\n")
        result_text.insert(tk.END, f"📄 엑셀 변환 완료 - {current_time}\n")
        result_text.insert(tk.END, f"파일: {file_path}\n")
        result_text.insert(tk.END, f"{'='*120}\n\n")

        # ✅ 성공/실패 통계 출력
        result_text.insert(tk.END, f"-- 총 {len(df)}개 중 {success_count}개 성공, {fail_count}개 실패\n\n")

        # ✅ 수용가번호 목록 먼저 출력
        result_text.insert(tk.END, "-- ✅ 임포트전 조회할 수용가목록\n")
        result_text.insert(tk.END, ",\n".join(f"'{x}'" for x in success_admin_no_list) + "\n\n")

        # ✅ SQL VALUES 출력
        result_text.insert(tk.END, ",\n".join(values_list))
        result_text.insert(tk.END, "\n\n")
        result_text.see(tk.END)
        result_text.config(state=tk.DISABLED)

    except Exception as e:
        messagebox.showerror("에러 발생", str(e))


def read_google_sheet(sheet_url, credentials_path, worksheet_name):
    gc = gspread.service_account(filename=credentials_path)
    sh = gc.open_by_url(sheet_url)
    worksheet = sh.worksheet(worksheet_name)
    
    # 데이터 범위를 명시적으로 지정 (A1부터 충분히 큰 범위까지)
    all_values = worksheet.get('A1:Z1000')  # A1부터 Z열 1000행까지
    
    if not all_values:
        return pd.DataFrame(columns=['계정명', '서비스코드', '수용가번호길이', '고객번호구조'])
    
    # 첫 행에서 원하는 컬럼의 인덱스 찾기
    header = all_values[0]
    
    # 디버깅: 헤더 전체 출력
    print(f"\n[DEBUG] 헤더 전체 ({len(header)}개 컬럼):")
    for idx, col in enumerate(header):
        if col:  # 비어있지 않은 컬럼만 출력
            print(f"  {idx}: '{col}'")
    
    # 중복된 컬럼명 처리: 서비스코드 옆에 있는 계정명 사용
    # 서비스코드를 먼저 찾고, 그 앞의 계정명을 사용
    idx_service = header.index('서비스코드')
    idx_len = header.index('수용가번호길이')
    idx_struct = header.index('고객번호구조')
    
    # 서비스코드 바로 앞 컬럼이 계정명인지 확인
    if idx_service > 0 and header[idx_service - 1] == '계정명':
        idx_account = idx_service - 1
    else:
        # 모든 '계정명' 컬럼 찾기
        account_indices = [i for i, col in enumerate(header) if col == '계정명']
        print(f"[DEBUG] '계정명' 컬럼 발견 위치: {account_indices}")
        # 서비스코드에 가장 가까운 계정명 사용
        idx_account = min(account_indices, key=lambda x: abs(x - idx_service))
    
    # 원하는 컬럼만 추출 (빈 행도 포함하여 모든 행 검사)
    data = []
    skipped = []
    for i, row in enumerate(all_values[1:], start=2):
        # 행이 비어있으면 건너뛰기
        if not row or len(row) == 0:
            continue
        
        # 각 컬럼 값 가져오기 (안전하게)
        account = row[idx_account] if idx_account < len(row) else ''
        service = row[idx_service] if idx_service < len(row) else ''
        num_len = row[idx_len] if idx_len < len(row) else ''
        struct = row[idx_struct] if idx_struct < len(row) else ''
        
        # 4개 필드 모두 값이 있는지 확인
        if account and service and num_len and struct:
            # 고객번호구조의 길이가 수용가번호길이와 일치하는지 검증
            try:
                expected_len = int(num_len)
                actual_len = len(struct)
                
                if actual_len == expected_len:
                    data.append([account, service, num_len, struct])
                else:
                    skipped.append(f"행 {i}: 계정명='{account}' - 길이 불일치 (수용가번호길이={expected_len}, 고객번호구조길이={actual_len}, 고객번호구조='{struct}')")
            except ValueError:
                skipped.append(f"행 {i}: 계정명='{account}' - 수용가번호길이가 숫자가 아님 ('{num_len}')")
        else:
            # 하나라도 비어있으면 건너뛰기 (디버깅용 기록)
            if account or service or num_len or struct:  # 하나라도 값이 있으면 기록
                skipped.append(f"행 {i}: 계정명='{account}', 서비스코드='{service}', 수용가번호길이='{num_len}', 고객번호구조='{struct}'")
    
    df = pd.DataFrame(data, columns=['계정명', '서비스코드', '수용가번호길이', '고객번호구조'])
    
    # ============ 디버깅 정보 출력 ============
    print("\n" + "="*80)
    print("📊 Google Sheets 데이터 로딩 결과")
    print("="*80)
    print(f"전체 읽은 행 수: {len(all_values)-1}개")
    print(f"✅ 유효한 계정명: {len(df)}개")
    print(f"❌ 필터링된 행: {len(skipped)}개")
    print(f"\n컬럼 인덱스: 계정명={idx_account}, 서비스코드={idx_service}, 수용가번호길이={idx_len}, 고객번호구조={idx_struct}")
    
    if skipped:
        print(f"\n{'='*80}")
        print(f"❌ 필터링된 행 목록 및 사유 ({len(skipped)}개)")
        print(f"{'='*80}")
        
        # 사유별로 분류
        reason_no_account = []
        reason_no_service = []
        reason_length_mismatch = []
        reason_incomplete = []
        reason_invalid_numlen = []
        
        for s in skipped:
            if "계정명=''" in s and "서비스코드=''" not in s:
                reason_no_account.append(s)
            elif "서비스코드=''" in s:
                reason_no_service.append(s)
            elif "길이 불일치" in s:
                reason_length_mismatch.append(s)
            elif "숫자가 아님" in s:
                reason_invalid_numlen.append(s)
            else:
                reason_incomplete.append(s)
        
        if reason_no_account:
            print(f"\n[계정명 없음] ({len(reason_no_account)}개)")
            for s in reason_no_account:
                print(f"  {s}")
        
        if reason_no_service:
            print(f"\n[서비스코드 없음] ({len(reason_no_service)}개)")
            for s in reason_no_service:
                print(f"  {s}")
        
        if reason_length_mismatch:
            print(f"\n[고객번호구조 길이 불일치] ({len(reason_length_mismatch)}개)")
            for s in reason_length_mismatch:
                print(f"  {s}")
        
        if reason_invalid_numlen:
            print(f"\n[수용가번호길이 형식 오류] ({len(reason_invalid_numlen)}개)")
            for s in reason_invalid_numlen:
                print(f"  {s}")
        
        if reason_incomplete:
            print(f"\n[필드 누락] ({len(reason_incomplete)}개)")
            for s in reason_incomplete:
                print(f"  {s}")
    
    print(f"\n{'='*80}\n")
    return df

# 사용 예시
sheet_url = "https://docs.google.com/spreadsheets/d/10XO7o99fYr4e_I_etJF3_eCFa2_dsDs2egSWeu1GAls/edit#gid=679649875"
credentials_path = r"C:\제품등록\gcp9304-4410543fedf2.json"
worksheet_name = "IN형식"

df = read_google_sheet(sheet_url, credentials_path, worksheet_name)

# "계정명"과 "서비스코드" 컬럼만 출력 (디버그용)
# print(df[['계정명', '서비스코드']])

# =====================
# 📌 GUI 구성 (Tkinter)
# =====================
window = tk.Tk()
window.title("임포트체커 (v251029)")
window.geometry("1000x600")

# 아이콘 설정
try:
    # exe로 실행되는지 확인
    if getattr(sys, 'frozen', False):
        # exe로 실행 중: _MEIPASS 경로 사용
        icon_path = os.path.join(sys._MEIPASS, 'istec_icon.ico')
    else:
        # 일반 Python 실행: 현재 스크립트 경로 사용
        script_dir = os.path.dirname(os.path.abspath(__file__))
        icon_path = os.path.join(script_dir, 'istec_icon.ico')
    
    if os.path.exists(icon_path):
        window.iconbitmap(icon_path)
except Exception as e:
    # 아이콘 로드 실패 시 무시
    pass

# ▶ 계정명 콤보박스 프레임
site_frame = tk.Frame(window)
site_frame.pack(fill=tk.X, padx=10, pady=(10, 0))

site_label = tk.Label(site_frame, text="계정명 선택:")
site_label.pack(side=tk.LEFT)

# DB 상태 표시 라벨 (계정명 옆에)
default_db = ACCOUNT_DB_CONFIGS.get('경북포항', {'host': 'N/A', 'port': 'N/A'})
db_status_label = tk.Label(window, text=f"🌐 현재 DB: {default_db['host']}:{default_db['port']} (경북포항)", fg='#4CAF50', font=('Arial', 9))
db_status_label.pack(fill=tk.X, padx=10, pady=(5, 0))

exclude_accounts = ['나라장터', '농촌공사', '로우리스', '']
filtered_df = df[~df['계정명'].isin(exclude_accounts)].copy()
filtered_df = filtered_df.sort_values('계정명').reset_index(drop=True)

# 디버깅: 계정명 목록 출력
print(f"[DEBUG] 로드된 계정명 개수: {len(filtered_df)}")
print(f"[DEBUG] 계정명 목록:\n{filtered_df['계정명'].tolist()}")

# 전체 계정명 목록 저장 (검색용)
all_account_names = list(filtered_df['계정명'])

# 계정명 입력을 위한 프레임 (자동완성용)
account_autocomplete_frame = tk.Frame(site_frame)
account_autocomplete_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 0))

# 계정명 입력창 (Entry 사용)
site_entry = tk.Entry(account_autocomplete_frame)
site_entry.pack(fill=tk.X)

# 자동완성 리스트박스 (처음엔 숨김)
site_listbox = tk.Listbox(account_autocomplete_frame, height=8, fg='black', selectbackground='#2196F3')
site_listbox.pack_forget()  # 처음엔 숨김

# 선택된 계정명 저장 변수
selected_account = tk.StringVar()

# 계정명 자동완성 + 실시간 검색 + 동적 필터링 기능
def update_autocomplete(event=None):
    """타이핑할 때마다 실시간으로 필터링된 리스트 표시"""
    # 특수 키 처리
    if event:
        if event.keysym == 'Down':
            # 아래 화살표: 리스트박스로 포커스 이동
            if site_listbox.size() > 0:
                site_listbox.pack(fill=tk.BOTH, expand=True)
                site_listbox.focus()
                site_listbox.selection_clear(0, tk.END)
                site_listbox.selection_set(0)
                site_listbox.see(0)
            return 'break'
        elif event.keysym == 'Escape':
            # ESC: 리스트박스 숨기기
            site_listbox.pack_forget()
            return 'break'
        elif event.keysym in ['Return', 'Tab']:
            # Enter/Tab 처리는 별도 함수에서
            return
        elif event.keysym in ['Up', 'Left', 'Right', 'Shift_L', 'Shift_R', 'Control_L', 'Control_R']:
            return
    
    # 현재 입력된 텍스트 가져오기
    typed_text = site_entry.get()
    
    # 리스트박스 업데이트
    site_listbox.delete(0, tk.END)
    
    if typed_text == '':
        # 입력이 비어있으면 전체 목록 표시
        for name in all_account_names:
            # 네트워크 정보가 있는 계정명은 ★ 마커 추가
            if name in ACCOUNT_DB_CONFIGS:
                site_listbox.insert(tk.END, f"★ {name}")
            else:
                site_listbox.insert(tk.END, name)
    else:
        # 입력된 텍스트를 포함하는 계정명만 필터링
        typed_lower = typed_text.lower()
        filtered = [name for name in all_account_names if typed_lower in name.lower()]
        for name in filtered:
            # 네트워크 정보가 있는 계정명은 ★ 마커 추가
            if name in ACCOUNT_DB_CONFIGS:
                site_listbox.insert(tk.END, f"★ {name}")
            else:
                site_listbox.insert(tk.END, name)
    
    # 필터링 결과가 있으면 리스트박스 표시
    if site_listbox.size() > 0:
        site_listbox.pack(fill=tk.BOTH, expand=True)
    else:
        site_listbox.pack_forget()

def on_account_enter(event):
    """Enter 키: 첫 번째 항목 선택 또는 리스트박스에서 선택된 항목 적용"""
    if site_listbox.winfo_viewable() and site_listbox.curselection():
        # 리스트박스에서 선택된 항목
        selection = site_listbox.get(site_listbox.curselection())
        # ★ 마커 제거
        selection = selection.replace('★ ', '')
        site_entry.delete(0, tk.END)
        site_entry.insert(0, selection)
        selected_account.set(selection)
        site_listbox.pack_forget()
    elif site_listbox.size() > 0:
        # 리스트박스 첫 번째 항목
        first_item = site_listbox.get(0)
        # ★ 마커 제거
        first_item = first_item.replace('★ ', '')
        site_entry.delete(0, tk.END)
        site_entry.insert(0, first_item)
        selected_account.set(first_item)
        site_listbox.pack_forget()
    return 'break'

def on_listbox_select(event):
    """리스트박스에서 항목 클릭 시"""
    if site_listbox.curselection():
        selection = site_listbox.get(site_listbox.curselection())
        # ★ 마커 제거
        selection = selection.replace('★ ', '')
        site_entry.delete(0, tk.END)
        site_entry.insert(0, selection)
        selected_account.set(selection)
        site_listbox.pack_forget()
        site_entry.focus()
        # 계정 정보 표시
        window.after(100, show_account_info)
        # DB 설정이 있는 계정만 자동 연결 테스트
        if selection.replace('★ ', '') in ACCOUNT_DB_CONFIGS:
            window.after(500, test_db_connection)

def on_listbox_key(event):
    """리스트박스에서 키 입력 처리"""
    if event.keysym == 'Return':
        on_listbox_select(event)
        return 'break'
    elif event.keysym == 'Escape':
        site_listbox.pack_forget()
        site_entry.focus()
        return 'break'

# 계정명 변경 감지 (선택 시 정보 팝업 및 DB 설정 변경)
def show_account_info():
    """선택된 계정명의 상세 정보 표시 및 DB 설정 자동 변경"""
    selected_name = site_entry.get()
    if not selected_name:
        return
    
    # filtered_df에서 선택된 계정명 찾기
    matches = filtered_df[filtered_df['계정명'] == selected_name]
    if not matches.empty:
        account_name = matches.iloc[0]['계정명']
        service_code = matches.iloc[0]['서비스코드']
        num_len = matches.iloc[0]['수용가번호길이']
        struct = matches.iloc[0]['고객번호구조']
        
        # DB 설정 확인 및 표시
        db_config = get_db_config(account_name)
        
        if db_config is None:
            # 네트워크 정보가 없는 계정
            db_info = f"\n\n[DB 설정]\n❌ 네트워크 정보 없음"
            db_status_label.config(
                text=f"⚠️ '{account_name}' - DB 네트워크 정보 없음",
                fg='#F44336'
            )
        else:
            # 네트워크 정보가 있는 계정
            db_info = f"\n\n[DB 설정]\nHost: {db_config['host']}\nPort: {db_config['port']}"
            if account_name == '충남태안':
                db_status_label.config(
                    text=f"🌐 현재 DB: {db_config['host']}:{db_config['port']} (충남태안)",
                    fg='#FF5722'
                )
            elif account_name == '경북포항':
                db_status_label.config(
                    text=f"🌐 현재 DB: {db_config['host']}:{db_config['port']} (경북포항)",
                    fg='#4CAF50'
                )
            else:
                db_status_label.config(
                    text=f"🌐 현재 DB: {db_config['host']}:{db_config['port']} ({account_name})",
                    fg='#2196F3'
                )
        
        messagebox.showinfo(
            "선택한 계정",
            f"계정명: {account_name}\n서비스코드: {service_code}\n수용가번호길이: {num_len}\n고객번호구조: {struct}{db_info}"
        )

# Enter 키로 선택 시 정보 표시 및 DB 연결 테스트 추가
original_on_account_enter = on_account_enter
def on_account_enter_with_info(event):
    result = original_on_account_enter(event)
    # Enter로 선택 완료 후 정보 표시
    window.after(100, show_account_info)
    # DB 설정이 있는 계정만 자동 연결 테스트
    selected_name = site_entry.get().strip()
    if selected_name in ACCOUNT_DB_CONFIGS:
        window.after(500, test_db_connection)
    return result

# 이벤트 바인딩
site_entry.bind('<KeyRelease>', update_autocomplete)
site_entry.bind('<Return>', on_account_enter_with_info)
site_listbox.bind('<Double-Button-1>', on_listbox_select)
site_listbox.bind('<Return>', on_listbox_key)
site_listbox.bind('<Escape>', on_listbox_key)

# 기본값 "경북포항" 설정
try:
    site_entry.insert(0, '경북포항')
    selected_account.set('경북포항')
except Exception:
    pass

# ▶ 소속/단말회사 입력 프레임
company_frame = tk.Frame(window)
company_frame.pack(fill=tk.X, padx=10, pady=(10, 0))

company_label = tk.Label(company_frame, text="소속/단말회사 (십진수):")
company_label.pack(side=tk.LEFT)

company_entry = tk.Entry(company_frame, width=20)
company_entry.pack(side=tk.LEFT, padx=(5, 0))
company_entry.insert(0, "6")  # 기본값 6

# ▶ DB 비밀번호 입력 프레임
db_password_frame = tk.Frame(window)
db_password_frame.pack(fill=tk.X, padx=10, pady=(10, 0))

db_password_label = tk.Label(db_password_frame, text="DB 비밀번호:")
db_password_label.pack(side=tk.LEFT)

db_password_entry = tk.Entry(db_password_frame, width=20, show='*')
db_password_entry.pack(side=tk.LEFT, padx=(5, 0))
db_password_entry.insert(0, "mars@icbm")  # 기본값 설정

# ▶ 매핑 조회 입력 프레임
mapping_frame = tk.Frame(window)
mapping_frame.pack(fill=tk.X, padx=10, pady=(10, 0))

mapping_label = tk.Label(mapping_frame, text="매핑 관리 입력창:\n  조회/해제/원복: 수용가번호 또는 단말주번호\n  생성: 수용가번호,단말주번호 (예: 2-001302290000,01236564855)")
mapping_label.pack(anchor=tk.W)

mapping_input_frame = tk.Frame(mapping_frame)
mapping_input_frame.pack(fill=tk.BOTH, expand=True)

mapping_search_text = tk.Text(mapping_input_frame, height=5, width=60)
mapping_search_text.pack(side=tk.LEFT, padx=(0, 5))

mapping_scrollbar = tk.Scrollbar(mapping_input_frame, command=mapping_search_text.yview)
mapping_scrollbar.pack(side=tk.LEFT, fill=tk.Y)
mapping_search_text.config(yscrollcommand=mapping_scrollbar.set)

# 매핑 관리 버튼 프레임
mapping_buttons_frame = tk.Frame(mapping_frame)
mapping_buttons_frame.pack(pady=(5, 0))

mapping_search_btn = tk.Button(mapping_buttons_frame, text="조회", command=search_mapping, bg='#2196F3', fg='white', padx=15, pady=5)
mapping_search_btn.pack(side=tk.LEFT, padx=(0, 5))

mapping_create_btn = tk.Button(mapping_buttons_frame, text="매핑 생성", command=create_mapping, bg='#4CAF50', fg='white', padx=15, pady=5)
mapping_create_btn.pack(side=tk.LEFT, padx=5)

mapping_unlink_btn = tk.Button(mapping_buttons_frame, text="매핑해제", command=unlink_mapping, bg='#F44336', fg='white', padx=15, pady=5)
mapping_unlink_btn.pack(side=tk.LEFT, padx=5)

mapping_restore_btn = tk.Button(mapping_buttons_frame, text="매핑원복", command=restore_mapping, bg='#FF9800', fg='white', padx=15, pady=5)
mapping_restore_btn.pack(side=tk.LEFT, padx=5)

# ▶ 버튼 구성
button_frame = tk.Frame(window)
button_frame.pack(pady=10)

# 로그 초기화 함수
def clear_log():
    """결과 로그 초기화"""
    result_text.config(state=tk.NORMAL)
    result_text.delete(1.0, tk.END)
    result_text.insert(tk.END, f"📋 로그가 초기화되었습니다. - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    result_text.config(state=tk.DISABLED)

clear_log_btn = tk.Button(button_frame, text="로그 초기화", command=clear_log, bg='#9E9E9E', fg='white', padx=10)
clear_log_btn.pack(side=tk.LEFT, padx=5)

db_test_btn = tk.Button(button_frame, text="DB 연결 테스트", command=test_db_connection, bg='#4CAF50', fg='white', padx=10)
db_test_btn.pack(side=tk.LEFT, padx=5)

excel_btn = tk.Button(button_frame, text="엑셀 파일 선택 및 SQL 변환", command=generate_sql_from_excel, padx=10)
excel_btn.pack(side=tk.LEFT, padx=5)

# ▶ 결과 출력 프레임
frame = tk.Frame(window)
frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

# ▶ 가로 스크롤바
x_scrollbar = tk.Scrollbar(frame, orient=tk.HORIZONTAL)
x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)

# ▶ 세로 스크롤바
y_scrollbar = tk.Scrollbar(frame)
y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

# ▶ 결과 출력 텍스트창 (스크롤 가능)
result_text = tk.Text(frame, wrap=tk.NONE, xscrollcommand=x_scrollbar.set, yscrollcommand=y_scrollbar.set)
result_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

x_scrollbar.config(command=result_text.xview)
y_scrollbar.config(command=result_text.yview)

# ▶ 프로그램 시작 시 자동으로 DB 연결 테스트 실행 (500ms 후)
window.after(500, test_db_connection)

# ▶ 메인 루프 실행
window.mainloop()

